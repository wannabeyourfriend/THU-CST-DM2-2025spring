# 最小生成树

------

给定一张带边权的无向图，求出该图的最小生成树权重之和。如果不存在(即该图不联通)，则输出-1。

#### 输入

第 1 行包含空格隔开的顶点个数n(1≤n≤5000)和边的条数m(1≤m≤200000)。

第 2 行到第m+1行每行包含3个由空格隔开的整数uiui vivi wiwi，(1≤ui,vi≤n,1≤wi≤100000)(1≤ui,vi≤n,1≤wi≤100000)，表示点uiui和vivi间有一条长度为wiwi的无向边。

每行结尾都有换行符。

保证图中不存在自环，但可能存在重边。

#### 输出

如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 -1。

#### 输入样例1

```undefined
5 8
2 1 3
5 3 5
3 1 1
1 5 4
4 1 1
2 3 5
4 2 4
3 5 1
```

#### 输出样例1

```undefined
6
```

#### 输入样例2

```undefined
20 40
13 11 7
20 12 10
19 1 1
7 14 10
5 12 7
2 19 5
15 4 5
12 5 3
16 3 2
19 5 7
15 7 9
8 14 4
2 6 4
13 4 7
10 4 10
8 10 1
9 12 1
20 4 4
5 15 7
4 10 4
16 12 2
17 11 5
19 7 10
8 5 10
2 9 9
18 20 10
15 1 9
1 8 10
15 7 5
16 14 8
7 10 7
12 4 3
4 17 10
11 19 2
3 7 5
3 4 6
9 4 1
19 3 1
16 2 10
9 2 8
```

#### 输出样例2

```undefined
67
```

提示： 推荐大家使用kruskal算法搭配并查集实现本题





# 最小工时

------

给定各工序的时间和先序工序，利用PT图和关键路径的方法，求出完成所有工序的最少时间及各个工序允许延误的时间。

保证给出的先序工序中不存在环依赖。

#### 输入

第 1 行工序的个数 n(1<=n<=100)n(1<=n<=100)。

第 2 n+12 n+1 行包含空格隔开的工序号 V(i)V(i) ,所需时间 tt ,V(i)V(i)的先序工序的个数s(i)s(i)并紧跟s(i)s(i)个先序工序 Vpre(k)(k=1..s(i),0<=V(i)<n,0<=Vpre(k)<V(i))Vpre(k)(k=1..s(i),0<=V(i)<n,0<=Vpre(k)<V(i))。若无先序工序，则s(i)=0s(i)=0。保证工序号为ii的工序的所有前序工序标号均小于ii。

注：工序号 V(i)V(i)从第2行起，必定是顺序的从0到n−1n−1；可能有多个工序的先序工序为空。

输入和结果均不会超过int的范围。

#### 输出

输出文件共n+1行：

第1行，求出完成所有工序所需要的最少时间。

第2~n+1行，输出在以最少时间完成工序时，各工序最大允许延误时间。

#### 输入样例1

```undefined
5
0 1 0
1 3 1 0
2 1 1 0
3 5 2 0 1
4 2 2 0 2
```

#### 输出样例1

```undefined
9
0
0
5
0
5
```

#### 输入样例2

```undefined
20
0 10 0
1 2 0
2 9 2 0 1
3 10 1 2
4 3 0
5 6 0
6 1 0
7 7 0
8 2 2 0 7
9 4 3 1 3 6
10 5 3 1 5 8
11 1 3 5 6 9
12 3 1 6
13 3 0
14 7 6 2 6 9 10 12 13
15 10 2 3 7
16 3 3 0 13 15
17 7 1 3
18 5 2 0 14
19 3 5 1 9 10 14 17
```

#### 输出样例2

```undefined
45
0
8
0
0
42
22
28
19
16
0
16
11
29
30
0
3
3
6
0
2
```

提示： 由于保证工序号为ii的工序的所有前序工序标号均小于ii，因此123..n123..n是一个天然拓扑序